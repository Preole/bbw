{
 "NODES": {
  "CSS Class & ID Prefixes": {
   "title": "CSS Class & ID Prefixes",
   "src": "; \"\"\"css-\"\"\"\n: Strictly for styling purposes.\n\n; \"\"\"js-\"\"\"\n: Strictly for application logic.\n\n; \"\"\"js-css-\"\"\"\n: Used by application logic to control styling.\n  (Toggling visibility, red linking)\n\n; \"\"\"bbm-\"\"\"\n: CSS namespace custom classes and identifiers \n  coming out of the wiki text parser.\n\n",
   "tags": [
    "Front-end",
    "Back-end"
   ],
   "mime": "text/x-bbm",
   "created": 1395010882719,
   "edited": 1395011295023
  },
  "Possible Back-end Enhancement": {
   "title": "Possible Back-end Enhancement",
   "src": "Database\n========\n\nConsider separating tags from wiki entries, rather than \nintegrated as part of wiki entry objects. Tag objects should \nhave its own module for enforcing business constraints, which \nare essential for effective tagging (partitioning) of wiki \nentries based on categories. Specifically, \n\n- There can only be one unique tag per application instance,\n  determined by the tag name.\n- Each tag can refer to at most one unique wiki entry \n  identified by their title text.\n- Similarly, each wiki entry can be tagged at most once by \n  any given tag object.\n- Control characters **must be stripped** from tag names.\n- All consecutive white space characters in tag names **must**\n  be collapsed into a single ASCII white space. However, single\n  non-ASCII space characters are permitted to remain as they \n  are.\n\nWiki entries are not supposed to know which categories they \nbelong to; They should only need to know when they're last \nedited, the date they're created, its title and its source code.\n\n**Wiki entry objects** should also abide to the following rules:\n\n- One unique wiki entry title per application.\n- No control characters allowed in **Mime Type** and **Title**\n  fields.\n- In the same field, process white space in the same way as the \n  tag names do to its white space characters.\n\n\n\nDatabase Indexing\n=================\n\nCurrently, there are seven different kinds of indices in the \nwiki. The code necessary to generate the HTML DOM element and \nthe underlying data structure is verbose, often repeated and \ntedious. This is due to the nature of HTML DOM, which are \nmostly sequential and linear, opposed to a wiki which \nprovides random access.\n\nIf able, these indices should be isolated from the database \nobject as an aggregate, which will be generated on the fly.\n\n\nDatabase Object\n===============\n\nThe database object itself is a bit too simple; It's simply a \nraw javascript object that used property names for different \npurposes, sometimes leaving the property values unused. The \ndesign flaw can be seen with edges (directed links) between \nwiki entries, where an integer value \"1\" is used as a property \nvalue that doesn't contribute anything.\n\nThe database object should be a more formally defined data \nstructure, namely a Graph, with sufficient support for linking in \nreverse direction. Otherwise, finding all nodes that linked to a \nparticular node can be an expensive O(n^^2^^) operation.\n\n\n\nView Controller \n===============\n\nThe code base currently has severe problems with string literals \nrepeatedly used in different areas. The worst offending use case \nare **jQuery CSS selectors**, which often have little to no variation \nfrom one another, but are used as string literals because of the \nCSS selector syntax:\n\n\"\"\"\n$(\"#someConstantModule\").on(\"someEvent\", \".js-wlink\", ...)\n\nfunction doSomething(evt)\n{\n if ($(evt.target).hasClass(\"js-wlink\"))\n {\n  //Do something fancy.\n }\n}\n\"\"\"\n\nHere, the class \"js-wlink\" refers to \"javascript wiki links\", \nwhich opens a wiki entry when they're clicked. Due to the nature \nof CSS selectors, the string value has to be repeated every time \nthere's a different relationship regarding the link, such as \nwhether it's a descendant of a particular kind of \"\"\"div\"\"\". \nInstances of such string constants lead to difficult maintenance.\n\n\n\nAPI & Architecture Design Flaws\n===============================\n\n1. In order to find forward links within a wiki entry, the engine \n   must perform the following procedure every time a wiki entry is \n   saved.\n\n   1. Parse the text into HTML strings.\n   2. Build the HTML DOM.\n   3. Query the DOM for a list of links.\n\n   The third step in the parsing process is critical for indexing \n   orphaned entries and their back links, which are very convenient \n   features to end-users. The other two steps are basic plain text \n   - HTML transformation. None of these steps can be combined or \n   simplified at the current state of affairs.\n\n2. Rendering a wiki entry requires a database query to determine \n   whether to display links in a different way. (Red linking)\n\n3. The rendering engine should not have to generate the same data \n   structure as ones used within the database. (Retrieving \n   edges from HTML DOM)\n\n",
   "tags": [
    "Back-end"
   ],
   "mime": "text/x-bbm",
   "created": 1395004854914,
   "edited": 1395109548132
  },
  "Possible Front-end Enhancement": {
   "title": "Possible Front-end Enhancement",
   "src": "Editing Interface\n=================\n\nThe **mime type** field of the editing interface should be a \ndrop-down box offering a slew of choices with a default \npre-selected. A simple text field may be too primitive an \ninterface.\n\nThe **tags** field of the editing interface can use the same \ntreatment; Either selecting a pre-existing tag or enter a \nnew tag string manually.\n\nThe search & indexing result panel should have an explicit \nclose button, rather than relying on an empty search query \nto close it.\n\n\n\nImporting Interface\n===================\n\nThe current interface for importing is limited to reading \nUTF-8 encoded text. It should be extended to accept other \ncharacter sets in addition to UTF-8.",
   "tags": [
    "Front-end"
   ],
   "mime": "text/x-bbm",
   "created": 1395000557212,
   "edited": 1395259009396
  },
  "Enhancement Update": {
   "title": "Enhancement Update",
   "src": "March 22nd, 2014 Update\n=======================\n\nRegarding the issue with data store, I have decided to forfeit \nusing a separate data store for tags; Tightly coupling keywords \nand tags with wiki entries is only natural, because these tags \nonly have semantic meanings when they appear with these entries. \nI shall still enforce the business constraints required of tags \nand wiki entries.\n\nI have created a \"\"\"WikiNode\"\"\" utility class isolated from the \ndatabase singleton, which has its own data validation scheme. \n\nI have also curated a new Directed Graph class object, which \nwill be responsible as the formal data structure backing up the \ndatabase. The introduction of the data structure should also \nreduce redundancy for generating data structures for indices. \n(Not yet finished)\n\n\nNew Problems Identified\n-----------------------\n\n- Lack of Error Reporting, both on the UI level and the API level\n- Lack of Error detection and constraint enforcing at the API level",
   "tags": [
    "Uncategorized"
   ],
   "mime": "text/x-bbm",
   "created": 1395525216255,
   "edited": 1395525216247
  },
  "EntryPoint": {
   "title": "EntryPoint",
   "src": "Currently, the back-end of BareBonesWiki is a mess! I will write a proper manual\nand incorporate a humanely usable API, I promise.\n\nSee:\n\n- #<Enhancement Update>\n- #<Possible Back-end Enhancement>\n- #<Possible Front-end Enhancement>\n- #<CSS Class & ID Prefixes>",
   "tags": [
    "Uncategorized"
   ],
   "mime": "text/x-bbm",
   "created": 1394841548715,
   "edited": 1395525239864
  }
 },
 "EDGES": {
  "EntryPoint": {
   "Enhancement Update": 1,
   "Possible Back-end Enhancement": 1,
   "Possible Front-end Enhancement": 1,
   "CSS Class & ID Prefixes": 1
  }
 },
 "CONFIG": {
  "title": "BareBonesWiki-DeveloperManual",
  "startup": [
   "EntryPoint"
  ],
  "cfmDel": false,
  "cfmNav": false,
  "searchCase": false
 }
}