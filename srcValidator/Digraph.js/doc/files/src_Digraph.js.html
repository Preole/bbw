<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\Digraph.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Digraph.html">Digraph</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\Digraph.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">



var Digraph = (function (){

 var hasOwn = Object.prototype.hasOwnProperty;
 
 /**
  * An enumeration of edge types used in this directed graph. They will
  * enforce the following semantics within the graph.
  *
  * - &quot;LOOSE&quot;: Edges and nodes have no relationship with each other.
  * - &quot;HALF&quot;: Edges cannot have empty source endpoint. All outgoing edges
  *   are deleted from the node when it is removed.
  * - &quot;FULL&quot;: Edges cannot have any endpoint left dangling. All edges related 
  *   to the node will be removed when the node is removed.
  * 
  * @property Digraph.prototype.EDGE_ENUM
  * @type {object}
  * @final
  */
 var EDGE_ENUM =
 {
  LOOSE : &quot;loose&quot;,
  HALF : &quot;half&quot;,
  FULL : &quot;full&quot;
 };
 
 //Polyfills &amp; Type checking
 (function (){
  Object.keys = Object.keys || function (obj)
  {
   if (!isObj(obj) || obj === null)
   {
    throw new TypeError(&quot;Object.keys called on non-object&quot;);
   }
   var res = [];
   for (var each in obj)
   {
    if (hasOwn.call(obj, each)) {res.push(each);}
   }
   return res;
  };
 }());
 
 function isObj(obj)
 {
  return obj !== null &amp;&amp; (typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot;);
 }

 function isEmpty(obj)
 {
  for (var each in obj)
  {
   if (hasOwn.call(obj, each)) {return false;}
  }
  return true;
 }

 function isStr(obj)
 {
  return ((obj instanceof String) || (typeof obj === &quot;string&quot;));
 }
 
 function isArray(obj)
 {
  return (obj instanceof Array);
 }
 
 function isFunc(obj)
 {
  return (typeof obj === &quot;function&quot;);
 }

 function isNum(obj)
 {
  return (typeof obj === &quot;number&quot; || obj instanceof Number);
 }
 
 
 /**
  * A basic directed graph class. It contains basic nodes and edges 
  * manipulation methods with a fairly readable JSON serialization.
  *
  * @class Digraph
  * @constructor Digraph
  * @param [edgeType] {string} 
  * &quot;full&quot;, &quot;half&quot;, &quot;loose&quot;; One of the types in Digraph.prototype.EDGE_ENUM.
  * Refer to the property EDGE_ENUM for detailed behaviors.
  *
  * @param [selfLoop] {boolean} 
  * If true, adding self-loops raises errors.
  * @return {Digraph} a newly generated Digraph instance.
  */
 function Digraph(edgeType, selfLoop)
 {
  if (!(this instanceof Digraph)) {return new Digraph();}
  
  /**
   * Denotes whether the graph allows self-looping edges.
   * @property SELFLOOP
   * @final
   * @type {boolean}
   * @default false
   */
  this.SELFLOOP = !!selfLoop;
  
  
  
  /**
   * Denotes the degree of tolerance for edges with dangling endpoint.
   * @property EDGETYPE
   * @final
   * @type {string}
   * @default &quot;loose&quot; or Digraph.prototype.EDGE_ENUM.LOOSE
   */
  this.EDGETYPE = hasOwn.call(EDGE_ENUM, edgeType) ? edgeType : EDGE_ENUM.LOOSE;
  
  
  
  /**
   * A map of nodes&#x27; identifiers to their associated data.
   * 
   * Sample JSON for an employee catalog:
   * 
   * &#x60;&#x60;&#x60;
   * {
   *  &quot;Joe Smith&quot; : 
   *  {
   *   &quot;Name&quot; : &quot;Joe Smith&quot;,
   *   &quot;Phone&quot; : &quot;3333-333333-3333&quot;,
   *   &quot;EmploymentDateUTC : 8981214573
   *  }
   * }
   * &#x60;&#x60;&#x60;
   *
   * @property NODES
   * @type {object}
   */
  this.NODES = {};
  
  /**
   * A map of directed edges, where the keys are the source nodes&#x27; ID, and the
   * values are objects. The keys of the nested objects are the destination
   * node&#x27;s ID, and their values are the edge&#x27;s associated data.
   *
   * Sample JSON of a inter-personal relationship graph:
   *
   * &#x60;&#x60;&#x60;
   * {
   *  &quot;A&quot; : 
   *  {
   *   &quot;B&quot; : &quot;Abuse&quot;,
   *   &quot;C&quot; : &quot;Rivalry&quot;
   *  },
   *  &quot;B&quot; :
   *  {
   *   &quot;D&quot; : &quot;Friendship&quot;
   *  }
   * }
   * &#x60;&#x60;&#x60;
   *
   * @property EDGES
   * @type {object}
   */
  this.EDGES = {};
  this.TRANS = {};
  
  return this;
 }

 Digraph.prototype = (function (){

  var funcObj =
  {
   addNode : addNodeRoute,
   rmNode : rmNodeRoute,
   getNode : getNode,
   hasNode : hasNode,
   
   addEdge : addEdgeRoute,
   rmEdge : rmEdgeRoute,
   setEdge : setEdge,
   getEdge : getEdge,
   hasEdge : hasEdge,
   getEdgesIn : getEdgesIn,
   getEdgesOut : getEdgesOut,
   getDegreesIn : getDegreesIn,
   getDegreesOut : getDegreesOut,
   
   
   transpose : transpose,
   toJSON : toJSON,
   fromJSON : fromJSON,
   
   
   EDGE_ENUM : EDGE_ENUM
  };

  
  function edgeCheck(fromID, toID)
  {
   //Type checking for graph types &amp; Input parameters
   edgeCheckID.call(this, fromID, toID);   
   var existFrom = hasNode.call(this, fromID);
   var existTo = hasNode.call(this, toID);
   
   if (this.EDGETYPE === EDGE_ENUM.FULL &amp;&amp; !(existFrom &amp;&amp; existTo))
   {
    throw new TypeError(&quot;Both edge endpoints must exist in full-edge digraphs.&quot;);
   }
   if (this.EDGETYPE === EDGE_ENUM.HALF &amp;&amp; !(existTo))
   {
    throw new TypeError(&quot;Source edge endpoint must exist in half-edge digraphs.&quot;);
   }
   if (!this.SELFLOOP &amp;&amp; fromID === toID)
   {
    throw new TypeError(&quot;Self loops are disallowed in this digraph.&quot;)
   }
   return this;
  }

  function edgeCheckID(fromID, toID)
  {
   if (!(isStr(fromID) || isNum(fromID)) || !(isStr(toID) || isNum(toID)))
   {
    throw new TypeError(&quot;Edge endpoint identifiers must be strings or numbers.&quot;);
   }
  }


  /**
  * Adds a set of nodes into the graph.
  * @method addNode
  * @param obj {object} 
  * A mapping of node identifiers and their associated data values. The 
  * keys are the identifier, while the value is the data associated with 
  * the node.
  * @return {Digraph} The modified graph instance.
  */
  function addNodes(obj)
  {
   for (var key in obj)
   {
    addNode.call(this, key, obj[key]);
   }
   return this;
  }

  /**
   * Adds a node into the graph with a given identifier and a block
   * of data.
   * @method addNode
   * @param id {string} 
   * The identifier of the node.
   * @param [dataObj=null] {anything}
   * The data object of the node, which can be anything.
   * @return {Digraph} The modified graph instance.
   */
  function addNode(id, dataObj)
  {
   this.NODES[id] = arguments.length &gt;= 2 ? dataObj : null;
   return this;
  }
  
  function addNodeRoute()
  {
   if (arguments.length &gt;= 2)
   {
    addNode.apply(this, arguments);
   }
   return addNodes.apply(this, arguments);
  }


  /**
   * Kills a list of nodes, calling rmNode(id) for each identifier
   * in the array.
   * @method rmNode
   * @param idArray {Array of string} An array of identifier strings.
   * @return {Digraph} The modified graph instance.
   */
  function rmNodes(idArray)
  {
   for (var i = 0, ii = idArray.length; i &lt; ii; i += 1)
   {
    rmNode.call(this, idArray[i]);
   }
   return this;
  }

  /**
   * Kills a node with a given identifier if it exists.
   * For full-edge Digraphs, all edges associated with this node will be
   * removed, while half-edge digraphs will remove all outgoing edges of
   * this node.
   * @method rmNode
   * @param id {string} The node&#x27;s identifier string
   * @return {Digraph} The modified graph instance
   */
  function rmNode(id)
  {
   if (isStr(id))
   {
    delete this.NODES[id];
    
    if (this.EDGETYPE === EDGE_ENUM.FULL)
    {
     rmEdge.call(this, id);
     rmEdge.call(this, null, id);
    }
    else if (this.EDGETYPE === EDGE_ENUM.HALF)
    {
     rmEdge.call(this, id);
    }
   }
   return this;
  }

  function rmNodeRoute()
  {
   if (arguments[0] instanceof Array)
   {
    rmNode.apply(this, arguments);
   }
   return rmNodes.apply(this, arguments);
  }


  /**
   * Retrieves the data object of the node with the identifier id.
   * @method getNode()
   * @param id {string} The node&#x27;s identifier string
   * @return {anything} 
   * The data associated with the node if the node exists. Returns 
   * &#x60;undefined&#x60; otherwise.
   */
  function getNode(id)
  {
   if (hasOwn.call(this.NODES, id)) {return this.NODES[id];}
  }
  
  /**
   * Determines whether a node with the identifier id exists.
   * @method hasNode()
   * @param id {string} The node&#x27;s identifier string
   * @return {boolean} True if the node exists; false otherwise.
   */
  function hasNode(id)
  {
   return (hasOwn.call(this.NODES, id));
  }



  function addEdgesArray(key, strArr)
  {
   for (var i = 0, ii = strArr.length; i &lt; ii; i += 1)
   {
    addEdge.call(this, key, strArr[i], null);
   }
   return this;
  }
  
  function addEdgesObj(key, obj)
  {
   for (var target in obj)
   {
    addEdge.call(this, key, target, obj[target]);
   }
   return this;
  }
  
  /**
   * Adds a collection of directed edges into the graph.
   * @method addEdge
   * @param idObject {object} An object, where the keys are the identifiers
   * of the source node. The values can either be a string, object, or an 
   * array with the following formulations:
   *
   * - string: Adds a single directed edge from node A to node B. The data
   *   value for this edge shall be &#x60;null&#x60;.
   * - Array of strings: Adds a directed edge from node A to each node
   *   specified in the array. These edges&#x27; associated data will be the
   *   value &#x60;null&#x60;.
   * - Object: The keys denote the identifier of the destination node, 
   *   while the values denote any data associated with the edge object.
   * @return {Digraph}
   * The modified Digraph instance.
   * @throws {TypeError}
   * The same error as the three-parameter formulation.
   */
  function addEdges(obj)
  {
   for (var key in obj)
   {
    var targets = obj[key];
    
    if (isStr(targets))
    {
     addEdge.call(this, key, targets, null);
    }
    else if (isArray(targets))
    {
     addEdgesArray.call(this, key, targets);
    }
    else if (isObj(targets))
    {
     addEdgesObj.call(this, key, targets);
    }
   }
   return this;
  }

  /**
   * Adds one directed edge that points from node A to node B.
   * @method addEdge
   * @param fromID {string} Source node&#x27;s identifier
   * @param toID {string} Destination node&#x27;s identifier.
   * @param [data=null] {anything} Any data associated with the edge.
   * @return {Digraph} The modified Digraph instance.
   * @throws {TypeError} On one of the following situations:
   * - Full-edge graph &amp; either endpoint has no node.
   * - Half-edge graph &amp; source endpoint has no node.
   * - Self-loops in graphs that explicitly forbids it.
   * - Non-string identifiers in either fromID or toID.
   */
  function addEdge(fromID, toID, data)
  {
   edgeCheck.call(this, fromID, toID);
   
   var EDGES = this.EDGES[fromID] || {};
   var TRANS = this.TRANS[toID] || {};
   if (!hasOwn.call(this.EDGES, fromID))
   {
    this.EDGES[fromID] = EDGES;
   }
   if (!hasOwn.call(this.TRANS, toID))
   {
    this.TRANS[toID] = TRANS;
   }
   
   EDGES[toID] = data;
   TRANS[fromID] = data;
   
   return this;
  }
  
  function addEdgeRoute()
  {
   if (isStr(arguments[0]))
   {
    addEdge.apply(this, arguments);
   }
   return addEdges.apply(this, arguments);
  }



  function rmEdgesObj(key, obj)
  {
   for (var target in obj) 
   {
    rmEdge.call(this, key, target);
   }
   return this;
  }
  
  function rmEdgesArray(key, strArr)
  {
   for (var i = 0, ii = strArr.length; i &lt; ii; i += 1)
   {
    rmEdge.call(this, key, strArr[i]);
   }
   return this;
  }

  /**
   * Kills all outbound edge for all nodes in this array, specified by their
   * identifier string.
   * @method rmEdge
   * @param idArray {Array} An array of string (identifiers).
   * @return {Digraph} The modified Digraph instance.
   */
  function rmEdgesSrc(strArr)
  {
   for (var i = 0, ii = strArr.length; i &lt; ii; i += 1)
   {
    rmEdge.call(this, strArr[i]);
   }
  }
  
  /**
   * Kills a set of directed edges specified by the object. The option object
   * used in &#x60;addEdge(idObject)&#x60; shall remove the set of edges added by that 
   * object.
   * @method rmEdge
   * @param idObj {object or Array} The set of directed edges to remove.
   * @return {Digraph} The modified Digraph instance.
   */
  function rmEdges(obj)
  {
   for (var key in obj)
   {
    var targets = obj[key];
    if (isStr(targets))
    {
     rmEdge.call(this, key, targets);
    }
    else if (isArray(targets))
    {
     rmEdgesArray.call(this, key, targets);
    }
    else if (isObj(targets))
    {
     rmEdgesObj.call(this, key, targets);
    }
   }
   return this;
  }
  
  /**
   * Removes one, or a set of directed edges depending on the identifiers
   * specified for each endpoint:
   *
   * - Both parameters provided: Kills the directed edge A -&gt; B.
   * - First parameter only: Kills all outbound edges of A: A -&gt; *.
   * - Second parameter only : Kills all inbound edges of B: * -&gt; B.
   *
   * Does nothing if no parameters are supplied.
   * @method rmEdge
   * @param [fromID] {string} Identifier of the source node. May be omitted
   * if there&#x27;s a 2nd parameter.
   * @param [toID] {string} Identifier of the destination.
   * @return {Digraph} The modified Digraph instance.
   *
   */
  function rmEdge(fromID, toID)
  {
   var hasSrc = isStr(fromID) ? hasOwn.call(this.EDGES, fromID) : false;
   var hasSrcTrans = isStr(toID) ? hasOwn.call(this.TRANS, toID) : false;
   
   if (hasSrc &amp;&amp; hasSrcTrans)
   {
    delete this.EDGES[fromID][toID];
    delete this.TRANS[toID][fromID];
   }
   else if (hasSrc)
   {
    for (var dest in this.EDGES[fromID])
    {
     if (hasOwn.call(this.TRANS, dest))
     {
      delete this.TRANS[dest][fromID];
     }
    }
    delete this.EDGES[fromID];
   }
   else if (hasSrcTrans)
   {
    for (var dest in this.TRANS[toID])
    {
     if (hasOwn.call(this.EDGES, dest))
     {
      delete this.EDGES[dest][toID];
     }
    }
    delete this.TRANS[toID];
   }
   return this;
  }

  function rmEdgeRoute()
  {
   if (isStr(arguments[0]))
   {
    rmEdge.apply(this, arguments);
   }
   else if (isArray(arguments[0]))
   {
    rmEdgesSrc.apply(this, arguments);
   }
   return rmEdges.apply(this, arguments);
  }


  /**
   * Resets the edges from one node to another, or one node to a set of other
     nodes. Effectively the same as calling &#x60;rmEdge()&#x60; and &#x60;addEdge()&#x60; in that 
     order with the same parameters.
   * @method setEdge
   * @param fromID {string or Array or object} 
   * @param [toID] {string}
   * @return {Digraph} The modified Digraph instance.
   */
  function setEdge()
  {
   rmEdgeRoute.apply(this, arguments);
   addEdgeRoute.apply(this, arguments);
   return this;
  }


  /**
   * Retrieves a specified set of edge objects.
   * @method getEdge
   * @param [fromID] {string} Identifier of the source node.
   * @param [toID] {string} Identifier of the destination.
   * @return {anything} 
   * - If both parameters are supplied, returns the data object of the edge.
   * - If only the first parameter is supplied, same as &#x60;getEdgesOut()&#x60;.
   * - If only the 2nd parameter is provided, same as &#x60;getEdgesIn()&#x60;.
   * 
   * Omitting parameters returns the entire edge set, where the keys
     denote the source node identifier. Each key points to another object, 
     where their keys are the destination nodes&#x27; identifier, and their 
     values the data object of that edge.
   */
  function getEdge(fromID, toID)
  {
   var argLen = arguments.length;
   var hasSrc = isStr(fromID);
   var hasDest = isStr(toID);
   
   if (!hasSrc &amp;&amp; !hasDest)
   {
    return this.EDGES;
   }
   if (hasSrc &amp;&amp; !hasDest)
   {
    return getEdgesOut.call(this, fromID);
   }
   if (!hasSrc &amp;&amp; hasDest)
   {
    return getEdgesIn.call(this, toID);
   }
   if (hasEdge.call(this, fromID, toID))
   {
    return this.EDGES[fromID][toID];
   }
  }

  /**
   * Tests whether there&#x27;s a link from node A to node B.
   * @method hasEdge
   * @param fromID {string} Identifier of the source node.
   * @param toID {string} Identifier of the destination.
   * @return {boolean} true if there&#x27;s a link from &quot;fromID&quot; to &quot;toID&quot;
   * @throws {TypeError} Both parameters must be of type string.
   */
  function hasEdge(fromID, toID)
  {
   edgeCheckID(fromID, toID);
   
   var hasKey = hasOwn.call(this.EDGES, fromID);
   var hasVal = hasKey &amp;&amp; hasOwn.call(this.EDGES[fromID], toID);
   return hasKey &amp;&amp; hasVal;
  }

  /**
   * Retrieves all incoming edge objects going into a particular node.
   * @method getEdgesIn
   * @param nodeID {string} The identifier of the node.
   * @return {Object} An object, where the keys represent the source of
   * of the edge, and the value represents any data associated with the
   * edge object. Returns undefined if the node doesn&#x27;t exist.
   */
  function getEdgesIn(nodeID)
  {
   if (!isStr(nodeID) || !hasOwn.call(this.TRANS, nodeID)) {return;}
   return this.TRANS[nodeID];
  }

  /**
   * Retrieves all outgoing edge objects originating from a particular node.
   * @method getEdgesOut
   * @param nodeID {string} The identifier of the node.
   * @return {Object} An object, where the keys represent the destination
   * of the edge, and the value represents any data associated with the
   * edge object. Returns undefined if the node doesn&#x27;t exist.
   */
  function getEdgesOut(nodeID)
  {
   if (!isStr(nodeID) || !hasOwn.call(this.EDGES, nodeID)) {return;}
   return this.EDGES[nodeID];
  }
  
  /**
   * Retrieves the number of incoming edges into a particular node.
   * @method getDegreesIn
   * @param nodeID {string} The identifier of the node.
   * @return {Number} The number of incoming edges for the given node ID.
   * Returns 0 if the node doesn&#x27;t exist.
   */
  function getDegreesIn(nodeID)
  {
   var inEdges = getEdgesIn.call(this, nodeID);
   if (inEdges)
   {
    return Object.keys(inEdges).length;
   }
   return 0;
  }
  
  /**
   * Retrieves the number of outgoing edges from a particular node.
   * @method getDegreesOut
   * @param nodeID {string} The identifier of the node.
   * @return {Number} The number of outgoing edges for the given node ID.
   * Returns 0 if the node doesn&#x27;t exist.
   */
  function getDegreesOut(nodeID)
  {
   var outEdges = getEdgesOut.call(this, nodeID);
   if (outEdges)
   {
    return Object.keys(outEdges).length;
   }
   return 0;
  }

  /**
   * Reverse the direction of all edges in the graph.
   * @method transpose
   * @return {Digraph} The same Digraph transposed.
   */
  function transpose()
  {
   var temp = this.EDGES;
   this.EDGES = this.TRANS;
   this.TRANS = temp;
   
   return this;
  }

  /**
   * Generates a serializable view of the Digraph instance to be
   * turned into JSON string using JSON.stringify();
   * @method toJSON
   * @return {Object} The serializable version of the Digraph instance.
   */
  function toJSON()
  {
   return {
    SELFLOOP : this.SELFLOOP,
    EDGETYPE : this.EDGETYPE,
    NODES : this.NODES,
    EDGES : this.EDGES
   };
  }

  /**
   * Imports graph data with a JSON string or a plain javascript object.
   *
   * @method fromJSON
   * @param input {string or object} 
   * The graph data to import from. Effectively, it takes the &#x60;NODES&#x60; and 
   * &#x60;EDGES&#x60; property of the object and calls &#x60;addNodes()&#x60; followed by 
   * &#x60;addEdges()&#x60;.
   * @return {Digraph} The modified graph instance.
   * @throws {TypeError} 
   * If the import violates the semantic rules defined for edges in this 
   * graph, such as a graph containing self loops when it is explicitly
   * forbidden.
   */
  function fromRoute(input)
  {
   if (isStr(input))
   {
    fromJSON.call(this, input);
   }
   else if (isObj(input))
   {
    fromObj.call(this, input);
   }
   return this;
  }
  
  function fromJSON(str)
  {
   fromObj.call(this, JSON.parse(str));
   return this;
  }
  
  function fromObj(obj)
  {
   addNodeRoute.call(this, obj.NODES);
   addEdgeRoute.call(this, obj.EDGES);
   return this;
  }
  
  return funcObj;
 }());




 return Digraph;
}());

//Node.js module export.
if (typeof module === &quot;object&quot;)
{
 module.exports = Digraph;
}



{
 &quot;A&quot; : 
  {
   &quot;B&quot; : Data
  }
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
